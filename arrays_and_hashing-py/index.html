<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Leetcode</title>

    <!-- MathJax for LaTeX-style equations -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Custom CSS for LaTeX-like font & formatting -->
    <style>
        body {
            font-family: "Cambria Math", "Times New Roman", serif;
            font-size: 18px;
            margin: 2cm;
            background-color: #fdfdfd;
        }

        h2 {
            font-family: "Cambria Math", "Times New Roman", serif;
            font-weight: bold;
            text-align: center;
        }

        details {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #004080;
            border-radius: 5px;
            background-color: #eef5ff;
        }

        summary {
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            color: #004080;
        }

        ul {
            margin: 10px;
            padding-left: 20px;
        }

        li {
            margin: 10px 0; /* Add margin to create space between bullet points */
        }

        pre {
            background-color: #eee;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: "Courier New", Courier, monospace;
            color: black;
        }

        .comment {
            color: green;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgb(0,0,0);
            background-color: rgba(0,0,0,0.4);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            border-radius: 10px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .highlight
        {
            background-color: yellow;
            cursor: pointer;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        
        /* Table styling */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 10px 0;
        }
        
        th, td {
            padding: 8px;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        th {
            background-color: #f2f2f2;
        }
        
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
<h2>Python Leetcode</h2>

<h3>Understanding Runtime (Brief Review)</h3>
<details>
    <summary><strong>Big O Notation</strong></summary>
    <ul>
        <li>What: A mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity.</li>
        <li>Why: It provides an upper bound on the growth rate of a function, helping to analyze the efficiency of algorithms.</li>
        <li>Common Notations in order from fastest to slowest:</li>
        <ul>
            <li>O(1): Constant time complexity</li>
            <li>O(log n): Logarithmic time complexity</li>
            <li>O(n): Linear time complexity</li>
            <li>O(n log n): Linearithmic time complexity</li>
            <li>O(n^2): Quadratic time complexity</li>
            <li>O(n^3): Cubic time complexity</li>
            <li>O(2^n): Exponential time complexity</li>
            <li>O(n!): Factorial time complexity</li>
        </ul>
    </ul>
</details>

<h3>Arrays and Hashing</h3>
<details>
    <summary><strong>Hash Usage</strong></summary>
    <details>
        <summary><strong>What are They and When do we use them?</strong></summary>
        <ul>
            <li><strong>Hash Sets</strong>: A collection that contains no duplicate elements and makes no guarantees about the order of elements.</li>
            <li><strong>Hash Maps</strong>: A collection of key-value pairs where each key is unique and makes no guarantees about the order of elements.</li>
            <li><strong>When to use Hash Sets:</strong></li>
            <table>
                <tr>
                    <th>Use a Hash-Set (set) when the problem asks you to...</th>
                    <th>Trigger words/phrases</th>
                    <th>Example Problem Titles</th>
                </tr>
                <tr>
                    <td>Test membership (existence)</td>
                    <td>"contains", "exists", "present"</td>
                    <td>Contains Duplicate</td>
                </tr>
                <tr>
                    <td>Enforce uniqueness</td>
                    <td>"unique", "distinct", "no duplicates"</td>
                    <td>Valid Anagram</td>
                </tr>
                <tr>
                    <td>Filter/remove duplicates</td>
                    <td>"remove duplicates", "deduplicate"</td>
                    <td>Intersection of Two Arrays II</td>
                </tr>
                <tr>
                    <td>Detect cycles</td>
                    <td>"cycle", "visited", "seen before"</td>
                    <td>Happy Number</td>
                </tr>
                <tr>
                    <td>Quickly check if something was seen before</td>
                    <td>"first non-repeating", "first unique"</td>
                    <td>First Unique Character in a String</td>
                </tr>
            </table>
            <li><strong>When to use Hash Maps:</strong></li>
            <table>
                <tr>
                    <th>Use a Hash-Map (dict) when you need to store a value associated with each key</th>
                    <th>Trigger words/phrases</th>
                    <th>Example Problem Titles</th>
                </tr>
                <tr>
                    <td>Count or track frequencies</td>
                    <td>"count", "frequency", "most frequent", "occurrences"</td>
                    <td>Top K Frequent Elements</td>
                </tr>
                <tr>
                    <td>Map one thing to another (e.g., value → index)</td>
                    <td>"index of", "pair sum", "two sum", "map to"</td>
                    <td>Two Sum</td>
                </tr>
                <tr>
                    <td>Group items by a key</td>
                    <td>"group by", "categorize", "bucket"</td>
                    <td>Group Anagrams</td>
                </tr>
                <tr>
                    <td>Cache or memoize results</td>
                    <td>"cache", "memoization", "lookup"</td>
                    <td>LRU Cache (extension)</td>
                </tr>
                <tr>
                    <td>Maintain key → data retrieval</td>
                    <td>"lookup", "get value", "retrieve"</td>
                    <td>Intersection of Two Arrays II</td>
                </tr>
            </table>
            <li><strong>Overall</strong></li>
            <table>
                <tr>
                    <th>Problem Pattern</th>
                    <th>Use a Set</th>
                    <th>Use a Map</th>
                </tr>
                <tr>
                    <td>Check if seen before</td>
                    <td>Yes</td>
                    <td>No</td>
                </tr>
                <tr>
                    <td>Count Frequencies</td>
                    <td>No</td>
                    <td>Yes</td>
                </tr>
                <tr>
                    <td>Lookup index by value</td>
                    <td>No</td>
                    <td>Yes</td>
                </tr>
                <tr>
                    <td>Unique Collection (no duplicates)</td>
                    <td>Yes</td>
                    <td>No</td>
                </tr>
                <tr>
                    <td>Key-Value Mapping</td>
                    <td>No</td>
                    <td>Yes</td>
                </tr>
            </table>

        </ul>
    </details>

    <details>
        <summary><strong>Hash Set Implementation</strong></summary>
        <!-- insert code-->
        <pre><code>  
    <span class="comment">#initialize an empty hash set</span>
    s = set()

    <span class="comment">#initialize a hash set with elements</span>
    s = set([1,2,3,4,5])

    <span class="comment">#Create set from list (automatically removes duplicates)</span>
    s = set([1,2,3,3]) <span class="comment">#-> {1,2,3}</span>

    <span class="comment">#Add Operation</span>
    s.add(6) <span class="comment">#s-> {1,2,3,4,5,6}</span>

    <span class="comment">#Remove Operation</span>
    s.remove(3) <span class="comment">#s-> {1,2,4,5,6}</span>

    <span class="comment">#Discard (safe) Operation</span>
    s.discard(3) <span class="comment">#-s -> {1,2,4,5,6}</span>

    <span class="comment">#pop operation</span>
    x = s.pop(5) <span class="comment">#x -> 5, s -> {1,2,4,6}</span>
    
    <span class="comment">#search operation</span>
    if 5 in s || s.__contains__(5):
        print("5 is in s")
    else:
        print("5 is not in s")

    <span class="comment">#length operation</span>
    len(s) <span class="comment">#-> 4</span>

    <span class="comment">#clear operation</span>
    s.clear() <span class="comment">#-> {}</span>

    <span class="comment">#copy operation</span>
    s2 = s.copy() <span class="comment">#s2 -> {1,2,4,6}</span>

    <span class="comment">#union operation</span>
    s3 = s.union(s2) <span class="comment">#s3 -> {1,2,4,6} (combines both sets and removes duplicates)</span>

    <span class="comment">#intersection operation</span>
    s4 = s.intersection(s2) <span class="comment">#s4 -> {1,2,4,6} (only elements present in both sets)</span>

    <span class="comment">#difference operation</span>
    s5 = s.difference(s2) <span class="comment">#s5 -> {1,2,4,6} (elements present in s but not in s2)</span>

    <span class="comment">#symmetric difference operation</span>
    s6 = s.symmetric_difference(s2) <span class="comment">#s6 -> {1,2,4,6} (elements present in either s or s2 but not both)</span>
    
    <span class="comment">#Removing duplicates from a list (key pattern 1)</span>
    unique = list(set(my_list))

    <span class="comment">#Check if two lists share a common element (key pattern 2)</span>
    if set(list1) & set(list2):
        print("Two lists share a common element")
    else:
        print("Two lists do not share a common element")
        </code></pre>
    </details>

    <details>
        <summary><strong>Hash Map Implementation</strong></summary>
        <!-- insert code-->
        <pre><code>
    <span class="comment">#initialize an empty hash map</span>
    d = {} || d = dict()

    <span class="comment">#initialize a hash map with elements</span>
    d = {'a': 1, 'b': 2, 'c': 3}



    <span class="comment">#insert operation</span>
    d['d'] = 4

    <span class="comment">#remove operation</span>
    d.pop('a')

    <span class="comment">#search operation</span>
    if 'b' in d:
        print("b is in d")
    else:
        print("b is not in d")

    <span class="comment">#length operation</span>
    len(d)

    <span class="comment">#clear operation</span>
    d.clear()

    <span class="comment">#copy operation</span>
    d2 = d.copy()

    <span class="comment">#frequency count (key pattern 3)</span>
    chars = ['b','a','n','a','n','a']
    freq = {}
    for char in chars:
        freq[char] = freq.get(char, 0) + 1
    print(freq)

    <span class="comment">#enumerate operation (key pattern 4)</span>
    for i, char in enumerate(chars): <span class="comment">#enumerate returns index and value of each element in a list</span>
        print(i, char)
    </code></pre>
    </details>
    <details>
        <summary><strong>Time and Space Complexity of Hash Sets and Hash Maps</strong></summary>
        <ul>
            <li>O(1) time complexity for insertion, deletion, and lookup</li>
            <li>O(n) time complexity for iteration</li>
            <li>O(n) space complexity for storing n elements</li>
            <li>O(b) space complexity for storing b buckets</li>
            <li>O(n+b) total space complexity</li>
        </ul>
    </details>
</details>

<!-- Arrays -->
<details>
    <summary><strong>Arrays (Static and Dynamic)</strong></summary>
    <details>
        <summary><strong>How do they differ? and When do we use them?</strong></summary>
        <ul>
            <li>Static Arrays: </li>
                <ul>
                    <li>Fixed size</li>
                    <li>Elements are stored in contiguous memory locations</li>
                    <li>Access elements by index in constant time O(1)</li> 
                </ul>
            <li>When to use static arrays:</li>
            <table>
                <tr>
                    <th>Use a static array when you need:</th>
                    <th>Trigger words/phrases</th>
                </tr>
                <tr>
                    <td>Fixed size</td>
                    <td>"fixed size", "static size", "limited capacity"</td
                </tr>
                <tr>
                    <td>Predictable memory allocation</td>
                    <td>"predictable memory allocation", "fixed memory allocation"</td>
                </tr>
                <tr>
                    <td>Memory efficiency</td> 
                    <td>"memory efficiency", "minimal memory usage"</td>
                </tr>
            </table>
            <li>Dynamic Arrays: </li>
                <ul>
                    <li>Variable size</li>
                    <li>Elements are stored in contiguous memory locations</li>
                    <li>Access elements by index in constant time O(1)</li>
                </ul>
            <li>When to use dynamic arrays:</li>
            <table>
                <tr>
                    <th>Use a dynamic array when you need:</th>
                    <th>Trigger words/phrases</th>
                </tr>
                <tr>
                    <td>Flexible size</td>
                    <td>"flexible size", "dynamic size", "variable capacity"</td>
                </tr>
                <tr>
                    <td>No memory wastage</td>
                    <td>"no memory wastage", "efficient memory usage"</td>
                </tr>
                <tr>
                    <td>Dynamic memory allocation</td>
                    <td>"dynamic memory allocation", "flexible memory allocation"</td>
                </tr>
            </table>
        </ul>
    </details>
    
    <details>
        <summary><strong>Implementation of Static Arrays</strong></summary>
        <!-- insert code-->
    <pre><code>
    <span class="comment">#initialize an empty static array</span>
    static_array = [0] * 5

    <span class="comment">#initialize a static array with elements</span>
    static_array = [1, 2, 3, 4, 5]
    
    <span class="comment">#access elements by index</span>
    print(static_array[0])

    <span class="comment">#modify elements by index</span>
    static_array[0] = 0

    <span class="comment">#length of array</span>
    len(static_array)

    <span class="comment">#iterate through array</span>
    for i in static_array:
        print(i)
    
    <span class="comment">#reverse array</span>
    static_array.reverse()

    <span class="comment">#sort array</span>
    static_array.sort()

    <span class="comment">#clear array</span>
    static_array.clear()

    <span class="comment">#check if array is empty</span>
    if not static_array:
        print("Array is empty")
    
    <span class="comment">#check if array is full</span>
    if len(static_array) == len(static_array):
        print("Array is full")
    
    <span class="comment">#insert element at index</span>
    static_array.insert(0, 0)

    <span class="comment">#remove element at index</span>
    static_array.pop(0)

    <span class="comment">#remove element by value</span>
    static_array.remove(0)
        
        
    </code></pre>
    </details>
    
    <details>
        <summary><strong>Implementation of Dynamic Arrays</strong></summary>
        <!-- insert code-->
        <pre><code>
        <span class="comment">#initialize an empty dynamic array</span>
        dynamic_array = []

        <span class="comment">#initialize a dynamic array with elements</span>
        dynamic_array = [1, 2, 3, 4, 5]
        
        <span class="comment">#access elements by index</span>
        print(dynamic_array[0])

        <span class="comment">#modify elements by index</span>
        dynamic_array[0] = 0

        <span class="comment">#length of array</span>
        len(dynamic_array)

        <span class="comment">#iterate through array</span>
        for i in dynamic_array:
            print(i)

        <span class="comment">#append element to array</span>
        dynamic_array.append(6) <span class="comment">#-> [1, 2, 3, 4, 5, 6]</span>

        <span class="comment">#insert element at index</span>
        dynamic_array.insert(0, 0)

        <span class="comment">#remove element at index</span>
        dynamic_array.pop(0)

        <span class="comment">#remove element by value</span>
        dynamic_array.remove(0)

        <span class="comment">#resize array</span>
        dynamic_array.resize(10) <span class="comment">#-> [1, 2, 3, 4, 5, 6, 0, 0, 0, 0]</span>

        <span class="comment">#check if array is full</span>
        if len(dynamic_array) == len(dynamic_array):
            print("Array is full")
            
        <span class="comment">#check if array is empty</span>
        if not dynamic_array:
            print("Array is empty")

        <span class="comment">#check if array is sorted</span>
        if dynamic_array == sorted(dynamic_array):
            print("Array is sorted")
        </code></pre>
    </details>

    <details>
        <summary><strong>Time and Space Complexity of Arrays</strong></summary>
        <ul>
            <li>O(1) time complexity for accessing elements by index</li>
            <li>O(n) time complexity for insertion and deletion at arbitrary positions</li>
            <li>O(n) space complexity for storing n elements</li>
            <li>O(b) space complexity for storing b buckets</li>
            <li>O(n+b) total space complexity</li>
        </ul>
    </details>
</details>
<!-- Arrays -->
<details>
    <summary><strong>Bucket Sort</strong></summary>
    <details>
        <summary><strong>What is it and When do we use it?</strong></summary>
        <ul>
            <li>What: Bucket sort is a sorting algorithm that works by dividing an array into a number of buckets, and then sorting each bucket individually.</li>
            <ul>
                <li>Buckets: Sub-arrays within the main array that store elements of the same value.</li>
                <li>Steps: 
                    <ol>
                        <li>Divide the array into buckets</li>
                        <li>Sort each bucket individually</li>
                        <li>Concatenate the buckets</li>
                    </ol>
                </li>
            </ul>
            <li>When to use it: </li>
            <ul>
                <li>When the array is uniformly distributed</li>
                <li>When the array is small</li>
                <li>When the array is already sorted</li>
            </ul>
        </ul>
    </details>
    
    <details>
        <summary><strong>Implementation of Bucket Sort</strong></summary>
    <!-- insert code-->
    <pre><code>
    <span class="comment">#initialize an empty bucket sort</span>
    bucket_sort = []

    <span class="comment">#initialize a bucket sort with elements</span>
    bucket_sort = [1, 2, 3, 4, 5]

    <span class="comment">#sort the array</span>
    bucket_sort.sort()

    <span class="comment">#concatenate the buckets</span>
    bucket_sort = bucket_sort[0] + bucket_sort[1] + bucket_sort[2] + bucket_sort[3] + bucket_sort[4]
    
    <span class="comment">#check if array is sorted</span>
    if bucket_sort == sorted(bucket_sort):
        print("Array is sorted")
    else:
        print("Array is not sorted")    
    </code></pre>
    </details>

    <details>
        <summary><strong>Time and Space Complexity of Bucket Sort</strong></summary>
        <ul>
            <li>Time Complexity: O(n+b)</li>
            <li>Space Complexity: O(n+b)</li>
        </ul>
    </details>
</details>

<!-- Vectors -->
<details>
    <summary><strong>Prefix Sums</strong></summary>
    <details>
        <summary><strong>What is it and When do we use it?</strong></summary>
        <ul>
            <li>What: Prefix sums are a technique used to store the sum of all elements in an array up to a certain index.</li>
            <ul>
                <li>Steps: 
                    <ol>
                        <li>Initialize a prefix sum array</li>
                        <li>Iterate through the array and store the sum of all elements up to the current index</li>
                    </ol>
            </ul>
            <li>When to use it: </li>
            <ul>
                <li>When we need to answer queries about the sum of subarrays</li>
            </ul>
        </ul>
    </details>
    <details>
        <summary><strong>Implementation of Prefix Sums</strong></summary>
        <!-- insert code-->
        <pre><code>
        <span class="comment">#initialize an empty prefix sum array</span>
        prefix_sum = []

        <span class="comment">#initialize a prefix sum array with elements</span>
        prefix_sum = [1, 2, 3, 4, 5]

        <span class="comment">#iterate through the array and store the sum of all elements up to the current index</span>
        if len(prefix_sum) > 0:
            for i in range(1, len(prefix_sum)):
                prefix_sum[i] = prefix_sum[i-1] + prefix_sum[i]

        <span class="comment">#print the prefix sum array</span>
        print(prefix_sum)

        <span class="comment">#answer queries about the sum of subarrays</span>
        print(prefix_sum[3] - prefix_sum[1])
        </code></pre>
    </details>
    
    <details>
        <summary><strong>Time and Space Complexity of Prefix Sums</strong></summary>
        <ul>
            <li>Time Complexity: O(n)</li>
            <li>Space Complexity: O(n)</li>
        </ul>
    </details>
</details>
<details>
    <summary><strong>String Manipulation</strong></summary>
    <details>
        <summary><strong>What is it and When do we use it?</strong></summary>
        <ul>
            <li>What: String manipulation is the process of manipulating strings to achieve a desired outcome.</li>
            <ul>
                <li>Steps: 
                    <ol>
                        <li>Initialize a string</li>
                        <li>Iterate through the string and manipulate it</li>
                        <li>Return the manipulated string</li>
                    </ol>
            </ul>
        </ul>
    </details>
    <details>
        <summary><strong>String Manipulation Operations</strong></summary>
        <pre><code>
        <span class="comment">#initialize a string</span>
        string = "Hello, World!"

    <span class="comment">#reverse a string</span>
    string[::-1] <span class="comment">#[::1]: start at the end of the string and step backwards</span>

    <span class="comment">#check if a string is a palindrome</span>
    string == string[::-1]

    <span class="comment">#count the number of vowels in a string</span>
    vowels = "aeiou"
    count = 0
    for char in string:
        if char in vowels:
            count += 1
    print(count)

    <span class="comment">#count the number of words in a string</span>
    words = string.split()
    print(len(words))
    
    <span class="comment">#check if reverse of string is a palindrome</span>
    </pre></code>
    </details>
</details>

    
<details>
    <summary><strong>Worked out Leetcode Solutions</strong></summary>
    <details>
        <summary><strong>Contains Duplicate</strong></summary>
        <pre><code>
        class Solution:
        def hasDuplicate(self, nums: List[int]) -> bool:
            #create set that removes duplicates from list
            s = list(set(nums))
            #if they are the same size (duplicates removed)
            if len(s) == len(nums):
                return False
            #not the same size (there are duplicates)
            else:
                return True
        </pre></code>
    </details>
    
    <details>
        <summary><strong>Valid Anagram</strong></summary>
        <pre><code>
        class Solution:
        def isAnagram(self, s: str, t: str) -> bool:
            freq1 = {}
            freq2 = {}
            for char in s:
                freq1[char] = freq1.get(char, 0) + 1
            for char in t:
                freq2[char] = freq2.get(char, 0) + 1
            if freq1 == freq2:
                return True
                freq1.clear()
                freq2.clear()
            else:
                return False
                freq1.clear()
                freq2.clear()
        </code></pre>
    </details>

    <details>
    <summary><strong>Two Sum</strong></summary>
    <pre><code>
    class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        <span class="comment">#we're working with a static array, want to return index of value and its complement -> map</span>
        hmap = {}
        <span class="comment">#list to hold result pair</span>
        pair = []
        if len(nums) > 0:
            for i in range(0, len(nums)):
                complement = target - nums[i]
                if (complement in hmap):
                    pair.append(hmap[complement])
                    pair.append(i)
                    break;
                <span class="comment">#set key to number, value to index</span>
                hmap[nums[i]] = i
            return pair
    </pre></code>
    </details>
    <details>
        <summary><strong>Group Anagrams</strong></summary>
        <ul>
            <li>Concepts to Consider:</li>
            <ul>
                <li>Words that are anagrams of each other form the same word when sorted</li>
                <li>brute-force: it takes nlogn time to sort a word and m time to iterate through each word in the list</li>
                <li>Better: We use a hash map where...</li>
                <ul>
                    <li>Key: the frequency of each letter in the word (ex: 1e, 1a, 1t)</li>
                    <li>value: the list of words that correspond to the key (ex: ["eat", "tea", "ate"])</li>
                    <li>Time complexity: O(n*m) where m is the number of input strings given and n is the average length of the strings</li>
                    <ul>
                        <li>to get n, we're counting how many of each character the string has</li>
                        <li>We would do this by creating a count array that represents the key</li>
                    </ul>
                </ul>
            </ul>
        </ul>
        <details>
            <summary><strong>Implementation</strong></summary>
            <pre><code>
            class Solution:
                def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
                <span class="comment">#create a hash map to store the key and value</span>
                hmap = defaultdict(list) <span class="comment">#defaultdict(list): if the key is not found, it will create a new list</span>
                <span class="comment">#iterate through each word in the list</span>
                for s in strs:
                    <span class="comment">#create a count array for each word.</span>
                    <span class="comment">#array will be the same size as the alphabet (26 letters)</span>
                    <span class="comment">#why we're doing this: count how many of each character the word has</span>
                    count = [0] * 26
                    <span class="comment">#iterate through each character in the word</span>
                    for c in s:
                        <span class="comment">#ord() returns the ASCII value of the character</span>
                        <span class="comment">#subtract ord('a') to get the index of the character in the count array</span>
                        count[ord(c) - ord('a')] += 1 <span class="comment">#count array will hold binary representation of the word</span>
                    <span class="comment">#set the count array as the key, and set the value to the string</span>
                    <span class="comment">#tuple() is used to convert the count array to a tuple</span>
                    <span class="comment">#why tuple? Makes it immutable; ensures that the count array is not changed</span>
                    hmap[tuple(count)].append(s) <span class="comment">#if the count array is already in the hash map, it will append the word to the already existing list</span>
                <span class="comment">#return the value (list of lists) of the hash map</span>
                return hmap.values() 
            </pre></code>
        </details>
        <details>
            <summary><strong>Top K Frequent Elements</strong></summary>
        </details>
    </details>
    <details>
        <summary><strong>Return K Top Frequent Elements</strong></summary>
        <pre><code>
        class Solution:
        def topKFrequent(self, nums: List[int], k: int) -> List[int]:
            hmap = {}
            for num in nums:
                <span class="comment">#create a hash map to store the number and its frequency</span>
                <span class="comment">#{1:1, 2:2, 3:3}</span>
                hmap[num] = hmap.get(num, 0) + 1
            <span class="comment">#1st param: iterate over dictionary keys</span>
            <span class="comment">#2nd param key=hmap.get: tell sorted() to compare by value instead of key</span>
            <span class="comment">#3rd param: reverse=True: start with largest values first</span>
            <span class="comment">#[:k]: take only first k elements from sorted sequence </span>
            return sorted(hmap, key=hmap.get, reverse=True)[:k]            
        </pre></code>
    </details>
    <details>
        <summary><strong>Valid Sudoku</strong></summary>
        <pre><code>
        class Solution:
        def isValidSudoku(self, board: List[List[str]]) -> bool:
            <span class="comment">#defaultdict(set): initializes the set for an index that doesnt exist in it yet</span>
            <span class="comment">#made so we can assign cols[c], rows[c] from the get-go</span>
            <span class="comment">#cols: set containing all values in col</span>
            cols = defaultdict(set)
            <span class="comment">#rows: set containing all values in row</span>
            rows = defaultdict(set)
            
            <span class="comment">#squares: all values in 3x3 box</span>
            squares = defaultdict(set)
    
            <span class="comment">#for each row/col (item in the box)</span>
            for r in range(9):
                for c in range(9):
                    if (board[r][c] == "."): <span class="comment">#if item is "." symbol</span>
                        continue
                    if (
                        board[r][c] in rows[r] or
                        board[r][c] in cols[c] or
                        <span class="comment">#squares[(r//3, c//3)]</span>
                        <span class="comment">#checks if duplicate in sub-box (3x3)</span>
                        board[r][c] in squares[(r//3, c//3)]
                    ):
                        return False
                    cols[c].add(board[r][c])
                    rows[r].add(board[r][c])
                    squares[(r // 3, c // 3)].add(board[r][c])
            return True 
        </code></pre>
    </details>
</details>
<h3>Two Pointers</h3>
<details>
    <summary><strong>What are they and when do we use them?</strong></summary>
    <ul>
            <li>What: Two pointers are a technique used to solve problems by using two pointers to traverse an array or string.</li>
        <li>When: We use two pointers when we need to find a pair of elements in an array that satisfy a certain condition.</li>
            <li>How: We use two pointers to traverse the array or string and check if the elements satisfy the condition.</li>
        </ul>
</details>
<details>
        <summary><strong>Implementation</strong></summary>
        <pre><code>
        <span class="comment">#check if palindrome</span>
        def isPalindrome(self, s: str) -> bool:
            <span class="comment">#two pointers</span>
            left = 0
            right = len(s) - 1

            <span class="comment">#iterate through the string</span>
            while left < right:
                if word[left] != word[right]:
                    return False
                left += 1
                right -= 1
            return True
        </code></pre>
    </details>
</details>
<h3>Sliding Window</h3>
<details>
    <summary><strong>What is it and when do we use it?</strong></summary>
</details>



<script>
function openModal(modalId) {
    document.getElementById(modalId).style.display = "block";
}

function closeModal(modalId) {
    document.getElementById(modalId).style.display = "none";
}

// Close the modal when clicking outside of it
window.onclick = function(event) {
    if (event.target.classList.contains('modal')) {
        event.target.style.display = "none";
    }
}
</script>

</body>
</html>


<!--
return k top frequent elements: pulling k items from list sorted by frequency from hash map
group anagrams: create key for each word, sort the word, append to list, and then return value (words)
-->